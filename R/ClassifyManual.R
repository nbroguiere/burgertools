#' Manual cell type classification by applying gates
#'
#' This function performs a cell type classification by gating.
#'
#' If a list of signatures (sign_a, sign_b...) has been scored with ScoreSignature, cell types (celltype_a, celltype_b...) are defined based on gates (value_xy cutoffs) of the form:
#' "celltype_a = sign_a > value_aa & sign_b < value_ab, celltype_b = sign_b > value_ba & sign_a < value_ab [...]"
#'
#' The signatures can also come from other sources, and simply need to be present as metadata columns, or can also be features of the current default assay. In case they are features, the data slot is used.
#'
#' @param object Seurat object. Must have metadata columns containing signature scores, such as those generated by ScoreSignatures, with names matching any gating filter supplied.
#' @param gates A string (chr) of cell type definitions, with cell types delimited by commas (,). The name of the cell type is given first, followed by equal (=) and a series of gates separated by AND symbol (&). Example: "celltype_a = sign_a > value_aa & sign_b < value_ab, celltype_b = sign_b > value_ba & sign_a < value_ab" where sign_a and sign_b are the names of metadata columns and value_xy are numeric values.
#' @param metadata.name The name of the new metadata column where cell type annotations are stored (Default: celltype)
#' @return A Seurat object with an additional metadata column containing the cell type annotations and Idents() set to these annotations. Cells which do not validate any gate defined are attributed the celltype "None" and cells which pass several gates are labelled "Multiplet".
#' @keywords Cell type classification celltype Classifier manual gates gating
#' @export
#' @examples
#' # MySeuratObject should contain an RNA slot with log-normalized data assay.
#' # In this example cells are classified as T cells (TC) or Epithelial cells (EP) based on manual signatures.
#' # Note that cells that validate no gate will have cell type "None", and cells which validate several will be classified as "Multiplets".
#' # It's recommended to first do a signature scatter plot in order to choose threshold values for the gates.
#' MySeuratObject <- Impute(MySeuratObject)
#' signature.list <- list(TCsign=c("CD3D","CD3E","CD3G","CD4","CD8A","CD8B","GZMA","IFNG"),
#'                        EPsign=c("EPCAM","TFF3","CDX2","CLDN3","KRT8","KRT19","KRT18","OLFM4"))
#' MySeuratObject <- ScoreSignatures(MySeuratObject,signature.list)
#' gates <- "TC = TCsign > 1.2 & EPsign < 0.2,
#'           EP = EPsign > 1.1 & TCsign < 0.3"
#' MySeuratObject <- ClassifyManual(MySeuratObject,gates)
#' DimPlot(MySeuratObject) # Plot the current Idents, set to "celltype".
ClassifyManual <- function(object, gates, metadata.name="celltype"){
  # Split by cell types:
  gates <- gsub(" ", "", gates)
  gates <- gsub("\n", "", gates)
  gates <- unlist(strsplit(gates,","))
  n_celltypes <- length(gates)

  # Split the cell type name from the gates:
  tmp <- strsplit(gates,"=")
  celltype_names <- unlist(lapply(tmp,"[",1))
  gates2 <- unlist(lapply(tmp,"[",2))

  # Split the gates:
  subgates <- strsplit(gates2,"&")

  # Create a df with the signatures and features to be used:
  signatures.available <- c(colnames(object@meta.data),rownames(object))
  unique.signatures.needed <- unique(unlist(lapply(strsplit(unlist(subgates),"<|>"),"[",1)))
  if(length(intersect(signatures.available,unique.signatures.needed))!=length(unique.signatures.needed)){
    error(paste0("Some features / signatures were not found in the metadata or current assay:\n",paste0(setdiff(unique.signatures.needed,signatures.available),collapse=" ")))
  }
  df <- cbind(object@meta.data[,intersect(colnames(object@meta.data),unique.signatures.needed)],
            t(as.data.frame(object[[DefaultAssay(object)]]@data[setdiff(unique.signatures.needed,colnames(object@meta.data)),])))

  # Initialize the cell type filter (start from keep all, to then restrict iteratively for each condition):
  filters <- matrix(data = TRUE, nrow = dim(object)[2], ncol = length(celltype_names), dimnames = list(rownames(df),celltype_names))

  # Go through the gates for one cell type at a time, to iteratively restrict the filters:
  for(i in 1:n_celltypes){
    for(j in 1:length(subgates[[i]])){
      gate_tmp <- subgates[[i]][j]
      is_greater <- length(grep(">",gate_tmp))
      if(is_greater){
        sign_use <- strsplit(gate_tmp,">")[[1]][1]
        cutoff <- as.numeric(strsplit(gate_tmp,">")[[1]][2])
        filters[,celltype_names[i]] <- filters[,celltype_names[i]] & df[,sign_use] > cutoff
      }else{
        sign_use <- strsplit(gate_tmp,"<")[[1]][1]
        cutoff <- as.numeric(strsplit(gate_tmp,"<")[[1]][2])
        filters[,celltype_names[i]] <- filters[,celltype_names[i]] & df[,sign_use] < cutoff
      }
    }
  }

  # Combine the filters to define unique cell types vs None vs Multiplets:
  n_cell_types <- rowSums(filters)
  celltype <- as.vector(matrix("None",nrow = dim(object)[2],ncol = 1))
  for(i in 1:ncol(filters)){
    celltype[as.vector(filters[,i])] <- celltype_names[i]
  }
  celltype[n_cell_types>1] <- "Multiplet"
  object@meta.data[,metadata.name] <- celltype
  Idents(object) <- object[[metadata.name]]
  return(object)
}
